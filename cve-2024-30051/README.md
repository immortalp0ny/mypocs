# CVE-2024-30051 dwmcore.dll Heap Buffer Overflow

Tested on 10.0.19045

The vulnerability is in the `CCommandBuffer::Initialize` function. We have an overflow because the memory size to be allocated is incorrectly calculated. The patch introduced a quick check for divisibility and in case the division operation ends with a remainder, the function terminates, btw memory is still allocated :)

Attempting to trace from where the vulnerable function is reachable gave the following results.

![graph](img/Pasted%20image%2020240905163046.png)

From the call tree, we have three options:

- `CSurfaceBrush::GetBrushParameters`.
- `CPrimitiveGroup::GenerateDrawList`.
- `CPrimitiveGroup::GetTextureMemoryLayoutData`.

I chose `CSurfaceBrush` to create the trigger.

I created a PoC that reaches the `CCommandBuffer::Initialize` code. In the creation I relied on the standard stacktrace, obtained by setting the breakpoint on the function `CSurfaceBrush::GetBrushParameters`. To create the PoC, I had to work with the `HelloComposition` example, from which it became clear how the resource tree should be constructed to reach the vulnerable code. 

Here is the resource tree that `HelloComposition` creates in order to draw a sprite of random size filled with a random color in a window:
![graph](img\Pasted%20image%2020240905163537.png)

Having analyzed the tree above and the example code, it is clear what conditions must be satisfied to reach the vulnerable code:

- Since it is necessary to run the renderer, a window is needed.
- The area in which the rendering takes place must be visible.
- Get a handle to [[Composition Window]] via `NtUserCreateDCompositionHwndTarget`.
- Open the handle on the [[Composition Window]] as `CVisualTargetMarshaler`.

Below you can see the resource tree satisfying the above conditions and leading to the vulnerability trigger.

![graph](img\Pasted%20image%2020240906205942.png)

In the images below you can see how the overflow occurs:

1. Memory allocation. RCX register contains 0x90, the size of the allocated memory.![graph](img\Pasted%20image%2020240906205959.png)
2. RAX contains a pointer to the allocated memory.![graph](img\Pasted%20image%2020240906210011.png)
3. State before memcpy. RCX contains the address of the destination buffer (allocated in past steps). RDX contains the address of the source buffer. R8 contains the size of the data to be copied. Here you can see that 0x90 < 0x95.![graph](img\Pasted%20image%2020240906210033.png)

## Build

```shell
    cd cve-2024-30051
    cmake -S . -B build
    cmake --build build --config Release
```
