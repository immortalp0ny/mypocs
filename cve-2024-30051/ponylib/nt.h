#ifndef _PONYLIB_NT
#define _PONYLIB_NT

#include "ponylib.h"

#include <functional>
#include <vector>
#include <algorithm>
#include <iterator>


namespace ponylib::nt {
    /*
        NT API Proxies
    */
    using nt_map_view_of_section_t = system_function_t<
        NTSTATUS (NTAPI*)(
            HANDLE          SectionHandle,
            HANDLE          ProcessHandle,
            PVOID           *BaseAddress,
            ULONG_PTR       ZeroBits,
            SIZE_T          CommitSize,
            PLARGE_INTEGER  SectionOffset,
            PSIZE_T         ViewSize,
            DWORD           InheritDisposition,
            ULONG           AllocationType,
            ULONG           Win32Protect
        )
    >;
    using nt_query_system_information_t = system_function_t<
        NTSTATUS(NTAPI*)(
            ULONG SystemInformationClass,
            PVOID SystemInformation,
            ULONG SystemInformationLength,
            PULONG ReturnLength
        )
    >;
    using nt_unmap_view_of_section_t = system_function_t<
        NTSTATUS(NTAPI*)(
            HANDLE ProcessHandle, 
            PVOID  BaseAddress
        )
    >;

    /*
        NT API Proxies constants
    */
    extern nt_map_view_of_section_t        kNtMapViewOfSection;
    extern nt_unmap_view_of_section_t      kNtUnmapViewOfSection;
    extern nt_query_system_information_t   kNtQuerySystemInformation;


    /*
        NT API Structs & Typedefs

        SYSTEM_PROCESS_INFORMATION, UNICODE_STRING, KPRIORITY, SYSTEM_THREAD_INFORMATION, SYSTEM_INFORMATION_CLASS taken from Scylla
            - https://github.com/NtQuery/Scylla/blob/master/Scylla/NativeWinApi.h
    */
   typedef LONG KPRIORITY;
   typedef struct _UNICODE_STRING {
        USHORT Length;
        USHORT MaximumLength;
        PWSTR  Buffer;
    } UNICODE_STRING, *PUNICODE_STRING;
    typedef struct _CLIENT_ID{
        HANDLE UniqueProcess;
        HANDLE UniqueThread;
    } CLIENT_ID, *PCLIENT_ID;
    typedef struct _SYSTEM_THREAD_INFORMATION
    {
        LARGE_INTEGER KernelTime;
        LARGE_INTEGER UserTime;
        LARGE_INTEGER CreateTime;
        ULONG WaitTime;
        PVOID StartAddress;
        CLIENT_ID ClientId;
        KPRIORITY Priority;
        LONG BasePriority;
        ULONG ContextSwitches;
        ULONG ThreadState;
        ULONG WaitReason;
    } SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;
    typedef struct _SYSTEM_PROCESS_INFORMATION
    {
        ULONG NextEntryOffset;
        ULONG NumberOfThreads;
        LARGE_INTEGER SpareLi1;
        LARGE_INTEGER SpareLi2;
        LARGE_INTEGER SpareLi3;
        LARGE_INTEGER CreateTime;
        LARGE_INTEGER UserTime;
        LARGE_INTEGER KernelTime;
        UNICODE_STRING ImageName;
        KPRIORITY BasePriority;
        HANDLE UniqueProcessId;
        HANDLE InheritedFromUniqueProcessId;
        ULONG HandleCount;
        ULONG SessionId;
        ULONG_PTR PageDirectoryBase;
        SIZE_T PeakVirtualSize;
        SIZE_T VirtualSize;
        ULONG PageFaultCount;
        SIZE_T PeakWorkingSetSize;
        SIZE_T WorkingSetSize;
        SIZE_T QuotaPeakPagedPoolUsage;
        SIZE_T QuotaPagedPoolUsage;
        SIZE_T QuotaPeakNonPagedPoolUsage;
        SIZE_T QuotaNonPagedPoolUsage;
        SIZE_T PagefileUsage;
        SIZE_T PeakPagefileUsage;
        SIZE_T PrivatePageCount;
        LARGE_INTEGER ReadOperationCount;
        LARGE_INTEGER WriteOperationCount;
        LARGE_INTEGER OtherOperationCount;
        LARGE_INTEGER ReadTransferCount;
        LARGE_INTEGER WriteTransferCount;
        LARGE_INTEGER OtherTransferCount;
        SYSTEM_THREAD_INFORMATION Threads[1];
    } SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;
    typedef enum _SYSTEM_INFORMATION_CLASS {
        SystemBasicInformation, 
        SystemProcessorInformation, 
        SystemPerformanceInformation, 
        SystemTimeOfDayInformation, 
        SystemPathInformation, 
        SystemProcessInformation, 
        SystemCallCountInformation, 
        SystemDeviceInformation, 
        SystemProcessorPerformanceInformation, 
        SystemFlagsInformation, 
        SystemCallTimeInformation, 
        SystemModuleInformation, 
        SystemLocksInformation, 
        SystemStackTraceInformation, 
        SystemPagedPoolInformation, 
        SystemNonPagedPoolInformation, 
        SystemHandleInformation, 
        SystemObjectInformation, 
        SystemPageFileInformation, 
        SystemVdmInstemulInformation, 
        SystemVdmBopInformation, 
        SystemFileCacheInformation, 
        SystemPoolTagInformation, 
        SystemInterruptInformation, 
        SystemDpcBehaviorInformation, 
        SystemFullMemoryInformation, 
        SystemLoadGdiDriverInformation, 
        SystemUnloadGdiDriverInformation, 
        SystemTimeAdjustmentInformation, 
        SystemSummaryMemoryInformation, 
        SystemNextEventIdInformation, 
        SystemEventIdsInformation, 
        SystemCrashDumpInformation, 
        SystemExceptionInformation, 
        SystemCrashDumpStateInformation, 
        SystemKernelDebuggerInformation, 
        SystemContextSwitchInformation, 
        SystemRegistryQuotaInformation, 
        SystemExtendServiceTableInformation, 
        SystemPrioritySeperation, 
        SystemPlugPlayBusInformation, 
        SystemDockInformation, 
        SystemPowerInformation2, 
        SystemProcessorSpeedInformation, 
        SystemCurrentTimeZoneInformation, 
        SystemLookasideInformation
    } SYSTEM_INFORMATION_CLASS;
    
    /*
        NT API Utils Impls
    */
    typedef struct _process_t {
        UINT32 processId;
        UINT32 sessionId;

        UINT64 imagebase;
        UINT64 imagesize;

        UINT64 peb;
        
        std::wstring filename;
        std::wstring fullpath;

    } process_t,*ptr_process_t;
    class proc_snapshot_t {
        protected:
            std::vector<process_t> m_processes;

        public:
            proc_snapshot_t() {}

            NTSTATUS build() {
                m_processes.clear();

                auto hHeap = GetProcessHeap();

                ULONG returnLength = 0;
                ULONG bufferLength = 0x1000;
                PSYSTEM_PROCESS_INFORMATION pBuffer = (PSYSTEM_PROCESS_INFORMATION)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, bufferLength);
                
                NTSTATUS status = (*kNtQuerySystemInformation)(SystemProcessInformation, pBuffer, bufferLength, &returnLength);
                while (status == 0xC0000004) {
                    HeapFree(hHeap, 0, pBuffer);
                    bufferLength += 0x1000;

                    pBuffer = (PSYSTEM_PROCESS_INFORMATION)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, bufferLength);

                    status = (*kNtQuerySystemInformation)(SystemProcessInformation, pBuffer, bufferLength, &returnLength);
                }
                if ( !NT_SUCCESS(status) ) {
                    HeapFree(hHeap, 0, pBuffer);

                    return status; 
                }

                PSYSTEM_PROCESS_INFORMATION pIter = pBuffer;
                while(TRUE) {
                    if (pIter->UniqueProcessId > (HANDLE)4) {

                        std::wstring imageName(pIter->ImageName.Buffer);
                        std::wstring imageFullName;

                        m_processes.push_back(
                            process_t {
                                (UINT32)    (pIter->UniqueProcessId),
                                (UINT32)    pIter->SessionId,
                                (UINT64)    0,
                                (UINT64)    0,
                                (UINT64)    0,
                                imageName,
                                imageFullName
                            }
                        );
                    }

                    if (pIter->NextEntryOffset == 0)
                    {
                        break;
                    }
                    else
                    {
                        pIter = (PSYSTEM_PROCESS_INFORMATION)((DWORD_PTR)pIter + (DWORD_PTR)pIter->NextEntryOffset);
                    }
                }

                return 0;
            }

            process_t& at(int i) {
                return m_processes.at(i);
            }

            std::vector<process_t> filter(std::function<bool(process_t&)> fn) {
                std::vector<process_t> filtered;
                std::copy_if(
                    m_processes.begin(),
                    m_processes.end(),
                    std::back_inserter(filtered),
                    fn
                );
                return filtered;
            };
    };
} 


#endif // _PONYLIB_NT